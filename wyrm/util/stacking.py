"""
:module: wyrm.util.stacking
:auth: Nathan T. Stevens
:email: ntsteven (at) uw.edu
:org: Pacific Northwest Seismic Network
:license: AGPL-3.0

:purpose:
    This module contains subroutines built on numpy that facilitate overlapping
    array stacking and buffering, largely used by the RtPredBuff class.

"""

import numpy as np


def shift_trim(array, npts_right, axis=None, fill_value=np.nan, dtype=None, **kwargs):
    """
    Execute a shift of values along a specified axis (default 0-axis),
    omitting (trimming) samples that fall out of the reference frame of the
    array and padding unoccupied sample positions with a specified `fill_value`

    Operation generates a copy of input `array` data, with modifications

    :: INPUTS ::
    :param array: [numpy.ndarray] target array to shift
    :param npts_right: [int] number of samples to shift contents, with a
                positive value indicating a rightward (increasing index)
                shift and a negative value indicating a leftward (decreasing
                index) shift
    :param axis: [int] axis over which to enact the leftshift
    :param fill_value: [scalar] fill_value to insert into empty index positions
                generated by shifting and trimming

    """
    if not isinstance(array, np.ndarray):
        raise TypeError('input "array" must be type numpy.ndarray')
    
    if not isinstance(npts_right, (int, float)):
        raise TypeError('npts_right must be int-like')
    elif isinstance(npts_right, float):
        npts_right = int(npts_right)
    
    if axis is None:
        pass
    elif axis + 1 > len(array.shape):
        raise IndexError(f'Axis {axis} is outside the dimensionality of array ({array.shape})')

    
    # End processing and return 
    if npts_right == 0:
        return array.copy()
    else:
        if dtype is None:
            tmp_array = np.full(shape=array.shape, fill_value=fill_value, dtype=array.dtype, **kwargs)
        else:
            tmp_array = np.full(shape=array.shape, fill_value=fill_value, **kwargs)

        # If ellipsis use case
        if axis is None:
            if npts_right > 0:
                tmp_array[npts_right, ...] = array.copy()[:-npts_right, ...]
            elif npts_right < 0:
                tmp_array[:-npts_right, ...] = array.copy()[npts_right:, ...]
        elif axis + 1 == len(array.shape) or axis == -1:
            if npts_right > 0:
                tmp_array[..., npts_right:] = array.copy()[..., :-npts_right]
            elif npts_right < 0:
                tmp_array[..., :-npts_right] = array.copy()[..., npts_right:]
        elif axis + 1 < len(array.shape):
            target_index = '['
            source_index = '['
            for _i in range(len(array.shape)):
                if _i != axis:
                    target_index += ':'
                    source_index += ':'
                else:
                    if npts_right > 0:
                        target_index += 'npts_right:'
                        source_index += ':-npts_right'
                    elif npts_right < 0:
                        target_index += ':-npts_right'
                        source_index == 'npts_right:'
                if _i + 1 < len(array.shape):
                    target_index += ', '
                    source_index += ', '
                else:
                    target_index += ']'
                    source_index += ']'
            eval(f'tmp_array{target_index} = array.copy(){source_index}')
    
    return tmp_array
