from wyrm.wyrms.wyrm import Wyrm
from wyrm.structures.rtinststream import RtInstStream
from wyrm.structures.window import MLInstWindow
import wyrm.util.seisbench_model_params as smp
import wyrm.util.input_compatability_checks as icc
import seisbench.models as sbm
from obspy import UTCDateTime
from collections import deque
from copy import deepcopy


class WindWyrm(Wyrm):
    """
    Initialize a WindWyrm object

    The WindWyrm class takes windowing information from an input
    seisbench.models.WaveformModel object and user-defined component
    mapping and data completeness metrics and provides a pulse method
    that iterates across entries in an input RtInstStream object and
    generates windowed copies of data therein that pass data completeness
    requirements. Windowed data are formatted as MLInstWindow objects and
    staged in the WindWyrm.queue attribute (a deque) that can be accessed
    by subsequent data pre-processing and ML prediction Wyrms.
    """

    def __init__(
        self,
        model_name=None,
        target_sr=100.0,
        target_npts=6000,
        target_in_channels=3,
        target_order="ZNE",
        target_overlap_npts=1800,
        target_blinding_npts=500,
        fill_value=0.0,
        z_valid_frac=0.95,
        Z_codes="Z3",
        h_valid_frac=0.8,
        N_codes="N1",
        E_codes="E2",
        missing_component_rule="Zeros",
        max_pulse_size=20,
        debug=False,
    ):
        """
        Initialize a WindWyrm object

        :: INPUTS ::
        :param model: [seisbench.models.WaveformModel] model object to
                        scrape information from on windowing parameters
                        Default provided here is the retrained EQTransformer
                        of Ni et al. (2023), but the input model does not
                        necessarily need to have weights loaded. Key values
                        scraped from the model for WindWyrm operation are:
                            sampling_rate
                            target_npts
                            blinding samples
                            overlap samples
                        the model is also referenced to each MLInstWindow
                        generated by this WindWyrm.
        :param z_valid_frac: [float] value must be in [0,1] - fraction of
                        a candidate window vertical component data
                        that must contain valid (non-masked) values to
                        indicate a candidate window can be generated.
        :param Z_codes: [str] component codes to associate with vertical
                        component data. Case sensitive.
                        NOTE: Z is used here to conform with SeisBench
                        component naming conventions
        :param h_valid_frac: [float] value must be in [0,1] - fraction of
                        a candidate window horizontal component data
                        that must contain valid (non-masked) values to
                        be included in output windows with valid vertical
                        component data.
        :param N_codes: [str] component codes to associate with north
                        component data. Case sensitive.
                        NOTE: N is used here to conform with SeisBench
                        component naming conventions
        :param E_codes: [str] component codes to associate with east
                        component data. Case sensitive.
                        NOTE: E is used here to conform with SeisBench
                        component naming conventions
        :param window_fill_value: [None] or [float] value to pass to
                        output MLInstWindow objects generated by this
                        WindWyrm to use as their standard fill_value
        :param missing_component_rule: [str]
                        missing horizontal component data rule to pass to
                        output MLInstWindow objects. Accepted values are:
                            "Zeros", "CloneZ", "CloneHZ".
                        -> see wyrm.structures.window.MLInstWindow() documentation
                        for more information
        :param max_pulse_size: [int] maximum pulse size for this Wyrm
                    NOTE: Pulse size is used here to determine the maximum
                          number of times to run through an input RtInstStream
                          object to try to generate windows. I.e., a pulse
                          size of 3 would make up to 3 attempts at generating
                          sequential windows from the input RtInstStream
        :param debug: [bool] run this Wyrm in debug mode?
                    NOTE: Currently does noting
        """
        Wyrm.__init__(self, max_pulse_size=max_pulse_size, debug=debug)
        # Set window-related attributes' placeholder values
        # Target sampling rate
        self._target_sr = None
        # Target window dimensions
        self._target_npts = None
        self._target_channels = None
        # Target window channel ordering
        self._target_order = None
        # Target window overlap parameters
        self._target_overlap = None
        self._target_blinding = None
        # Default window fill_value to pass to InstWindow
        self._fill_value = None
        # Holders for ML model information
        self._model_name = None
        self._model = None
        # Derivative values
        self._window_sec = None
        self._advance_sec = None
        self._overlap_sec = None
        self._blinding_sec = None

        # Set windOW_attrIBUTES
        self.set_target_window_attributes(
            target_sr=target_sr,
            target_npts=target_npts,
            target_in_channels=target_in_channels,
            target_order=target_order,
            target_overlap_npts=target_overlap_npts,
            target_blinding_npts=target_blinding_npts,
            fill_value=fill_value,
        )

        # Compatability check for missing_component_rule
        if isinstance(missing_component_rule, str):
            if missing_component_rule.lower() in ["zeros", "clonez", "clonehz"]:
                _missing_component_rule = missing_component_rule
            else:
                raise ValueError(
                    'missing_component_rule must be in: "Zeros", "CloneZ", "CloneHZ"'
                )
        else:
            raise TypeError("missing_component_rule must be type str")

        # Compatability check for z_valid_frac
        self._zvft = icc.bounded_floatlike(
            z_valid_frac, name="z_valid_frac", minimum=0, maximum=1
        )
        # Compatability check for h_valid_frac
        self._hvft = icc.bounded_floatlike(
            h_valid_frac, name="h_valid_frac", minimum=0, maximum=1
        )
        # Compatability check for Z_codes
        if isinstance(Z_codes, str):
            self._Z_codes = Z_codes
        else:
            raise TypeError("Z_codes must be type str")
        # Compatability check for N_codes
        if isinstance(N_codes, str):
            self._N_codes = N_codes
        else:
            raise TypeError("N_codes must be type str")
        # Compatability check for E_codes
        if isinstance(E_codes, str):
            self._E_codes = E_codes
        else:
            raise TypeError("E_codes must be type str")

        # Use horizontal valid fraction threshold to guide
        # maximum tolerance for mismatching start/endtimes
        tolsec = self._window_sec * (1.0 - self._hvft) * 0.5

        # Initialize default attributes
        self._ml_inst_window_kwargs = {
            "fill_value": self.target_window_attributes["fill_value"],
            "tolsec": tolsec,
            "missing_component_rule": _missing_component_rule,
            "model": self.model,
        }
        self.index = {}
        self.default_starttime = None
        # NOTE: Must have a non-UTCDateTime default value
        self.queue = deque([])

    def set_window_attributes(
        self,
        target_sr=None,
        target_npts=None,
        target_channels=None,
        target_order=None,
        target_overlap=None,
        target_blinding=None,
        target_fill_value=None,
    ):
        """
        Set (or update) attributes that specify the target dimensions
        of the windows being generated by this WindowWyrm
        """

        # Compatability check for target_sr
        if target_sr is not None:
            self._target_sr = icc.bounded_floatlike(
                target_sr, name="target_sr", minimum=0, maximum=None, inclusive=False
            )

        # Compatability check for target_npts
        if target_npts is not None:
            self._target_npts = icc.bounded_intlike(
                target_npts,
                name="target_npts",
                minimum=0,
                maximum=None,
                inclusive=False,
            )
        # Compatability check for target_channels
        if target_channels is not None:
            self._target_channels = icc.bounded_intlike(
                target_channels,
                name="target_in_channels",
                minimum=1,
                maximum=6,
                inclusive=True,
            )
        # Compatability check for target_order:
        if target_order is not None:
            if all(_c in "ZNE" for _c in target_order):
                if len(target_order) == self._target_channels:
                    self._target_order = target_order
                else:
                    raise ValueError(
                        "number of elements in target order must match target_channels"
                    )
            else:
                raise SyntaxError("target order must include Z, N, E")

        # Compatability check for target_overlap_npts
        if target_overlap is not None:
            self._target_overlap = icc.bounded_intlike(
                target_overlap,
                name="target_overlap",
                minimum=-1,
                maximum=self.target_npts,
                inclusive=False,
            )
        # Compatability check for target_blinding_npts
        if target_blinding is not None:
            self._target_blinding = icc.bounded_intlike(
                target_blinding,
                name="target_blinding",
                minimum=0,
                maximum=self.target_npts,
                inclusive=True,
            )
        # Compatability check for window_fill_value
        if target_fill_value is not None:
            self._fill_value = icc.bounded_floatlike(
                target_fill_value,
                name="target_fill_value",
                minimum=None,
                maximum=None,
                inclusive=False,
            )
        # UPDATE DERIVATIVE ATTRIBUTES
        # If all inputs are not None for window length in seconds, update
        if self._target_sr is not None:
            # if npts and sr are not None - get window_sec
            if self._target_npts is not None:
                self._window_sec = self._target_npts / self._target_sr
                # if npts, sr, and overlap are not None - get advance_sec
                if self._target_overlap is not None:
                    adv_npts = self._target_npts - self._target_overlap
                    
                    self._advance_sec = adv_npts/self._target_sr
                
        return self

    def populate_from_seisbench(self, model=sbm.EQTransformer().from_pretrained("pnw")):
        """
        Populate/update attributes from a seisbench.model.WaveformModel type object
        for this WindWyrm
        """
        if not isinstance(model, sbm.WaveformModel):
            raise TypeError("model must be a seisbench.models.WaveformModel")
        else:
            # update associated model
            self.model = model
            self.model_name = model.name

            # Update window attributers
            self.update_window_atributes(
                new_target_sr=model.sampling_rate,
                new_target_npts=model.in_samples,
                new_target_in_channels=model.in_channels,
                new_target_overlap_npts=model._annotate_args["overlap"][-1],
                new_target_blinding_npts=model._annotate_args["blinding"][-1][0],
            )
            # Get window advance seconds
            self._advance_sec = self.get_window_advance_seconds()
            self._window_sec = self.model.target_npts / self.model.sampling_rate
            self._blinding_sec = (
                smp.get_blinding(self.model)[0] / self.model.sampling_rate
            )

    def _update_target_window_attributes(self):
        """
        Helper method for updating the model associated with this
        WindWyrm and derivative attributes
            ._advance_sec
            ._window_sec
            ._blinding_sec
            ._windowing_args
        :: INPUT ::
        :param model: [seisbench.models.WaveformModel]
        """
        if not isinstance(model, sbm.WaveformModel):
            raise TypeError("model must be a seisbench.models.WaveformModel")
        else:
            # Tag Model as an attribute
            self.model = model
            # Update window advance seconds
            self._advance_sec = self.get_window_advance_seconds()
            # Update window length in seconds
            self._window_sec = self.model.target_npts / self.model.sampling_rate
            # Update blinding seconds
            self._blinding_sec = smp.get_blinding(self.model) / self.model.sampling_rate
            # Update model in _windowing_args dict
            self._windowing_args.update({"model": model})
        return self

    def get_window_advance_seconds(self):
        """
        Helper method to calculate the window advance
        size in seconds using the overlap, target_npts,
        and sampling_rate information associated with
        self.model

        :: OUTPUT ::
        :return asec: [float] window advance step in seconds
        """
        npts = self.model.target_npts
        opts = smp.get_overlap(self.model)
        apts = npts - opts
        asec = apts / self.model.sampling_rate
        return asec

    def _branch2instwindow(
        self,
        branch,
        next_window_starttime,
        pad=True,
        extra_sec=1.0,
        wgt_taper_sec=0.0,
        wgt_taper_type="cosine",
    ):
        """
        Using a specified candidate window starttime and windowing information
        attributes in this WindWyrm, determine if and input branch from a
        RtInstStream object has enough data to generate a viable window

        :param branch: [dict] of [wyrm.structures.rtbufftrace.RtBuffTrace] objects
                            with keys corresponding to RtBuffTrace datas' component
                            code (e.g., for BHN -> branch = {'N': RtBuffTrace()})
        :param next_window_starttime: [UTCDateTime] start time of the candidate window
        :param pad: [bool] should data windowed from RtBuffTrace objects be padded
                           (i.e., allow for generating masked data?)
                           see obspy.core.trace.Trace.trim() for more information
        :param extra_sec: [None] or [float] extra padding to place around windowed
                            data. Must be a positive value or None. None results in
                            extra_sec = 0.
                            NOTE: Extra samples encompassed by the extra_sec padding
                            on each end of windows are only included after a candidate
                            window has been deemed to have sufficient data. They do not
                            factor into the determination of if a candidate window
                            is valid
        :param wgt_taper_sec: [str] or [float-like] amount of seconds on each end
                            of a candidate window to downweight using a specified
                            taper function when assessing the fraction of the window
                            that contains valid data.
                            Supported string arguments:
                                'blinding' - uses the blinding defined by the ML model
                                associated with this WindWyrm to set the taper length
                            float-like inputs must be g.e. 0 and finite
        :param wgt_taper_type: [str] name of taper to apply to data weighting mask when
                                determining the fraction of data that are valid in a
                                candidate window
                            Supported string arguments:
                                'cosine':   apply a cosine taper of length
                                            wgt_taper_sec to each end of a
                                            data weighting mask
                                    aliases: 'cos', 'tukey'
                                'step':     set weights of samples in wgt_taper_sec of each
                                            end of a candidate window to 0, otherwise weights
                                            are 1 for unmasked values and 0 for masked values
                                    aliases: 'h', 'heaviside'
        :: OUTPUT ::
        :return window: [wyrm.structures.MLInstWind] or [None]
                        If a candidate window is valid, this method returns a populated
                        MLInstWind object, otherwise, it returns None

        """
        if not isinstance(branch, dict):
            raise TypeError("data_branch must be type dict")
        if not isinstance(next_window_starttime, UTCDateTime):
            raise TypeError("next_window_starttimest be type obspy.UTCDateTime")
        if not isinstance(pad, bool):
            raise TypeError("pad must be type bool")

        if extra_sec is None:
            extra_sec = 0
        else:
            extra_sec = icc.bounded_floatlike(
                extra_sec, name="extra_sec", minimum=0.0, maximum=self._window_sec
            )

        if wgt_taper_sec.lower() == "blinding":
            wgt_taper_sec = self._blinding_sec
        else:
            wgt_taper_sec = icc.bounded_floatlike(
                wgt_taper_sec,
                name="wgt_taper_sec",
                minimum=0.0,
                maximum=self._window_sec,
            )

        if not isinstance(wgt_taper_type, str):
            raise TypeError("wgt_taper_type must be type str")
        elif wgt_taper_type.lower() in ["cosine", "cos", "step", "heaviside", "h"]:
            wgt_taper_type = wgt_taper_type.lower()
        else:
            raise ValueError(
                'wgt_taper_type supported values: "cos", "cosine", "step", "heaviside", "h"'
            )

        # Create a copy of the kwargs to pass to MLInstWindow()
        window_inputs = self._windowing_args.copy()
        # Add target_starttime
        window_inputs.update({"target_starttime": next_window_starttime})

        # Calculate the expected end of the window
        next_window_endtime = next_window_starttime + self._window_sec
        # Compose kwarg dictionary for RtBuffTrace.get_trimmed_valid_fract()
        vfkwargs = {
            "starttime": next_window_starttime,
            "endtime": next_window_endtime,
            "wgt_taper_sec": wgt_taper_sec,
            "wgt_taper_type": wgt_taper_type,
        }
        # Iterate across component codes in branch
        for _k2 in branch.keys():
            # If _k2 is a Z component code
            if _k2 in self._Z_codes:
                # Pull RtBuffTrace
                zbuff = branch[_k2]
                # Get windowed valid fraction
                valid_fract = zbuff.get_trimmed_valid_fraction(**vfkwargs)
                # Check valid_fraction
                if valid_fract >= self._zvft:
                    # If sufficient data, trim a copy of the vertical data buffer
                    _tr = zbuff.to_trace()
                    _tr.trim(
                        starttime=next_window_starttime - extra_sec,
                        endtime=next_window_endtime + extra_sec,
                        pad=pad,
                        fill_value=None,
                    )
                    # Append to input holder
                    window_inputs.update({"Z": _tr})

            elif _k2 in self._N_codes + self._E_codes:
                hbuff = branch[_k2]
                valid_fract = hbuff.get_trimmed_valid_fraction(**vfkwargs)
                if valid_fract >= self._hvft:
                    # Convert a copy of the horizontal data buffer to trace
                    _tr = hbuff.to_trace()
                    # Trim data with option for extra_sec
                    _tr.trim(
                        starttime=next_window_starttime - extra_sec,
                        endtime=next_window_endtime + extra_sec,
                        pad=pad,
                        fill_value=None,
                    )
                    # Append to input holder with component sensitivity
                    if _k2 in self._N_codes:
                        window_inputs.update({"N": _tr})
                    elif _k2 in self._E_codes:
                        window_inputs.update({"E": _tr})
        if "Z" in window_inputs.keys():
            output = MLInstWindow(**window_inputs)
        else:
            output = None
        return output

    def _process_windows(
        self,
        rtinststream,
        extra_sec=None,
        pad=True,
        wgt_taper_sec="blinding",
        wgt_taper_type="cosine",
    ):
        """
        Iterates across all level 1 keys (_k1) of a RtInstStream object and
        assesses if each branch can produce a viable window, defined by having:
        1) Vertical component data specified by component codes in self._Z_codes
        2) Sufficient vertical data to satisfy the window size defined by the
            self.model.samping_rate and self.model.target_npts parameters and
            the z_valid_fract specified when initilalizing this WindWyrm. Additional
            settings are provide for downweighting window edge samples (see below)

        Additional data are ingested, if meeting comparable metrics,
        from horizontal channels if vertical channel data satisfy the
        requirements above.

        Successfully generated windowed data are copied into MLInstWindow objects
        and appended to this WindWyrm's queue with deque.leftappend()

        This method interacts with the WindWyrm.index dictionary, generating new
        entries for new instrument codes and initializing window starttime information

        For existing entries in WindWyrm.index, this method assesses if valid windows
        can be generated from a corresponding RtInstStream object data, generates
        windows in the event that one can be generated, and updates the index
        timing entry for when the next candidate window should start based on the
        overlap and sampling_rate specified in the SeisBench model associated
        with this WindWyrm.

        :: INPUTS ::
        :param rtinststream: [wyrm.structures.rtinststream.RtInstStream]
                            Realtime instrument stream object containing RtBuffTrace
                            objects
        -- kwargs passed to _branch2instwindow() --
            -> see its documentation for detailed descriptions of parameters
        :param extra_sec: [None] or [float] extra padding to place around
                            windowed data.
        :param pad: [bool] - allow padding when trimming
        :param wgt_taper_sec: [str] or [float] 'blinding' or float seconds
        :param wgt_taper_type: [str] 'cosine', 'step', or aliases thereof

        :: OUTPUT ::
        :return nnew: [int] number of new windows generated by this method
                        and added to the self.queue. Used as an early
                        termination criterion in self.pulse().
        """
        if not isinstance(rtinststream, RtInstStream):
            raise TypeError(
                f"rtinststream must be type wyrm.structures.rtinststream.RtInstStream"
            )

        nnew = 0
        for _k1 in rtinststream.keys():
            _branch = rtinststream[_k1]
            # If this branch does not exist in the WindWyrm.index
            if _k1 not in self.index.keys():
                self.index.update({_k1: self.default_starttime})
                next_starttime = self.index[_k1]

            # otherwise, alias matching index entry
            else:
                next_starttime = self.index[_k1]

            # If this branch has data for the first time
            if next_starttime == self.default_starttime:
                # Iterate across approved vertical component codes
                for _c in self._Z_codes:
                    # If there is a match
                    if _c in _branch.keys():
                        # and the matching RtBuffTrace in the branch has data
                        if len(_branch[_c]) > 0:
                            # use the RtBuffTrace starttime to initialize the windowing index
                            _first_ts = _branch[_c].stats.starttime
                            self.index.update({_k1: _first_ts})
                            next_starttime = _first_ts
                            # and break
                            break
            # Once the index has a UTCDateTime starttime
            if isinstance(next_starttime, UTCDateTime):
                # Do the match to the vertical trace buffer again
                # Set initial None-Type values for window edges
                _data_ts = None
                for _c in self._Z_codes:
                    if _c in _branch.keys():
                        if len(_branch[_c]) > 0:
                            # Grab start and end times
                            _data_ts = _branch[_c].stats.starttime
                            break
                # If vertical channel doesn't show up, warning and continue
                if _data_ts is None:
                    emsg = f"Error retrieving starttime from {_k1} "
                    emsg += f"vertical: {_branch.keys()}"
                    print(emsg)
                    continue
                # If data buffer starttime is before or at next_starttime
                elif _data_ts <= next_starttime:
                    pass
                # If update next_starttime if data buffer starttime is later
                # Simple treatment for a large data gap.
                elif _data_ts > next_starttime:
                    self.index.update({_k1: _data_ts})
                # Attempt to generate window from this branch
                ts = next_starttime
                window = self._branch2instwindow(
                    _branch,
                    ts,
                    pad=pad,
                    extra_sec=extra_sec,
                    wgt_taper_sec=wgt_taper_sec,
                    wgt_taper_type=wgt_taper_type,
                )
                # If window is generated
                if window:
                    # Add WindowMsg to queue
                    self.queue.appendleft(window)
                    # update nnew index for iteration reporting
                    nnew += 1
                    # advance next_starttime for this index by the advance
                    self.index[_k1] += self._advance_sec
                # If window is not generated, go to next instrument
                else:
                    continue

        return nnew

    def pulse(self, x):
        """
        Conduct up to the specified number of iterations of
        self._process_windows on an input RtInstStream object
        and return access to this WindWyrm's queue attribute

        Includes an early termination trigger if an iteration
        does not generate new windows.

        :: INPUT ::
        :param x: [wyrm.structure.stream.RtInstStream]

        :: OUTPUT ::
        :return y: [deque] deque of MLInstWindow objects
                    loaded with the appendleft() method, so
                    the oldest messages can be removed with
                    the pop() method in a subsequent step
        """
        if not isinstance(x, RtInstStream):
            raise TypeError(
                f"x must be type wyrm.structures.rtinststream.RtInstStream, got {type(x)}"
            )
        for _ in range(self.max_pulse_size):
            nnew = self._process_windows(x)
            if nnew == 0:
                break
        # Return y as access to WindWyrm.queue attribute
        y = self.queue
        return y
