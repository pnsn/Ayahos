"""
:module: wyrm.util.stacking
:auth: Nathan T. Stevens
:email: ntsteven (at) uw.edu
:org: Pacific Northwest Seismic Network
:license: AGPL-3.0

:purpose:
    This module contains subroutines built on numpy that facilitate overlapping
    array stacking and buffering, largely used by the RtPredBuff class.

"""

import numpy as np


def shift_trim(array, npts_right, axis=None, fill_value=np.nan, dtype=None, **kwargs):
    """
    Execute a shift of values along a specified axis (default 0-axis),
    omitting (trimming) samples that fall out of the reference frame of the
    array and padding unoccupied sample positions with a specified `fill_value`

    Operation generates a copy of input `array` data, with modifications

    :: INPUTS ::
    :param array: [numpy.ndarray] target array to shift
    :param npts_right: [int] number of samples to shift contents, with a
                positive value indicating a rightward (increasing index)
                shift and a negative value indicating a leftward (decreasing
                index) shift
    :param axis: [int] axis over which to enact the leftshift
    :param fill_value: [scalar] fill_value to insert into empty index positions
                generated by shifting and trimming

    """
    if not isinstance(array, np.ndarray):
        raise TypeError('input "array" must be type numpy.ndarray')
    
    if not isinstance(npts_right, (int, float)):
        raise TypeError('npts_right must be int-like')
    elif isinstance(npts_right, float):
        npts_right = int(npts_right)
    
    if axis is None:
        pass
    elif axis + 1 > len(array.shape):
        raise IndexError(f'Axis {axis} is outside the dimensionality of array ({array.shape})')

    
    # End processing and return 
    if npts_right == 0:
        return array.copy()
    else:
        if dtype is None:
            tmp_array = np.full(shape=array.shape, fill_value=fill_value, dtype=array.dtype, **kwargs)
        else:
            tmp_array = np.full(shape=array.shape, fill_value=fill_value, **kwargs)

        # If ellipsis use case
        if axis is None:
            # rightshift
            if npts_right > 0:
                tmp_array[npts_right:, ...] = array.copy()[:-npts_right, ...]
            # leftshift
            elif npts_right < 0:
                tmp_array[:npts_right, ...] = array.copy()[-npts_right:, ...]
            
        elif axis + 1 == array.ndim or axis == -1:
            # rightshift
            if npts_right > 0:
                tmp_array[..., npts_right:] = array.copy()[..., :-npts_right]
            # leftshift
            elif npts_right < 0:
                tmp_array[..., :npts_right] = array.copy()[..., -npts_right:]
        # hack-ey use of 'eval' to do dynamic indexing
        elif axis + 1 < array.ndim:
            # Start eval strings for indexing
            tmp_index = '['
            array_index = '['
            for _i in range(array.ndim):
                # If this is not the target axis, insert :
                if _i != axis:
                    tmp_index += ':'
                    array_index += ':'
                # If this is the target axis
                else:
                    # append rightshift slice
                    if npts_right > 0:
                        tmp_index += 'npts_right:'
                        array_index += ':-npts_right'
                    # append lefshift slice
                    elif npts_right < 0:
                        tmp_index += ':-npts_right'
                        array_index == 'npts_right:'
                # If this isn't the final axis, append a comma
                if _i + 1 < len(array.shape):
                    tmp_index += ', '
                    array_index += ', '
                # Otherwise, close out eval str
                else:
                    tmp_index += ']'
                    array_index += ']'
            eval(f'tmp_array{tmp_index} = array.copy(){array_index}')
    
    return tmp_array
